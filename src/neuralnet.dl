#define EULER 2.71828
#define ETA 0.5

.type InputID = number
.type NodeID = number
.type EdgeID = number

/***
 * Configuration
 */
.decl inputValue(id:InputID, node:NodeID, value:float)
.decl targetValue(id:InputID, node:NodeID, value:float)
.decl nodeBias(node:NodeID, value:float)
.decl node(id:NodeID, layer:number, index:number)
.decl edge(id:EdgeID, x:NodeID, y:NodeID)
.decl initialEdgeWeight(edge:EdgeID, initial_weight:float)

.input inputValue
.input targetValue
.input nodeBias
.input node
.input edge
.input initialEdgeWeight

/***
 * Input cleanup
 */
// Add in a dummy node to pass data into input layer
node(-1, -1, 0).

// Add in dummy edges from dummy node to input layer
.decl dummyEdge(id:EdgeID, x:NodeID, y:NodeID)
dummyEdge(-($+1), -1, id) :- inputValue(_, id, _).

edge(id, x, y) :- dummyEdge(id, x, y).
initialEdgeWeight(edge, value) :-
    dummyEdge(edge, -1, input_node),
    inputValue(_, input_node, value).

.decl edgeWeight(input_id:InputID, edge:EdgeID, weight:float)
edgeWeight(0, edge, weight) :- initialEdgeWeight(edge, weight).

/***
 * Forward propagation
 */
.decl forward(node:NodeID, value:float)
// Value of dummy start node is 1
forward(-1, 1).
forward(node, value + bias) :-
    node(node, layer, _),
    nodeBias(node, bias),
    forwardInductive(node, value, max_index),
    // stopping index is index of max prev layer node
    max_index = max index : { node(_, layer-1, index) }.

.decl activatedForward(node:NodeID, value:float)
activatedForward(node, value) :-
    forward(node, initial),
    node(node, layer, _),
    max_layer = max l : node(_, l, _),
    sigmoid = 1/(1+EULER^(-initial)),

    // sigmoid for output layer
    ((layer = max_layer, value = sigmoid);

    // sigmoid for hidden layers
     (layer < max_layer, layer > 0, value = sigmoid);

    // input nodes shouldnt change
     (layer <= 0, value = initial)).

// Inductive step to sum up all incoming values
// Induces an ordering based on previous layer indices
.decl forwardInductive(node:NodeID, rolling_value:float, index:number)
forwardInductive(node, 0.0, -1) :- node(node, _, _).
forwardInductive(node, prev_value + x1_value * weight, index) :-
    forwardInductive(node, prev_value, prev_index),
    index = prev_index + 1,
    node(x1, _, index),
    edge(edge, x1, node),
    edgeWeight(_, edge, weight),
    activatedForward(x1, x1_value).

/***
 * Back propagation
 */
.decl totalError(error:float)
totalError(error) :-
    error = 0.5 * (sum (x * x) : {
        x = target - actual,
        targetValue(_, node, target),
        activatedForward(node, actual)}).

.decl newEdgeWeight(edge:EdgeID, weight:float)
newEdgeWeight(edge, old_weight - ETA * deltaErrorVsWeight) :-
    !dummyEdge(edge, _, _), // ignore dummy edges
    edge(edge, _, _),
    edgeWeight(_, edge, old_weight),
    edgeDeltaErrorVsOut(edge, deltaErrorVsOut),
    edgeDeltaOutVsNet(edge, deltaOutVsNet),
    edgeDeltaNetVsWeight(edge, deltaNetVsWeight),
    deltaErrorVsWeight = deltaErrorVsOut * deltaOutVsNet * deltaNetVsWeight.

.decl edgeDeltaOutVsNet(edge:EdgeID, delta:float)
edgeDeltaOutVsNet(edge, delta) :-
    edge(edge, _, y),
    activatedForward(y, out),
    delta = out * (1 - out).

.decl edgeDeltaNetVsWeight(edge:EdgeID, delta:float)
edgeDeltaNetVsWeight(edge, delta) :-
    edge(edge, x, _),
    activatedForward(x, out),
    delta = out.

.decl edgeDeltaErrorVsOut(edge:EdgeID, delta:float)
// For output layer
edgeDeltaErrorVsOut(edge, delta) :-
    layer = max l : node(_, l, _),
    node(y, layer, _),
    targetValue(_, y, target),
    activatedForward(y, actual),
    edge(edge, _, y),
    delta = actual - target.

// For hidden layers
edgeDeltaErrorVsOut(edge, delta) :-
    edge(edge, _, y),
    node(y, layer, _),
    edgeDeltaErrorVsOutInductive(edge, delta, max_index),
    max_index = max idx : { node(_, layer+1, idx) }.

// Inductive relation to find dError/dOut for each hidden layer node
// Recursive sum aggregate of previous backpropagated error values
.decl edgeDeltaErrorVsOutInductive(edge:EdgeID, rolling_delta:float, index:number)
edgeDeltaErrorVsOutInductive(edge, 0, -1) :-
    edge(edge, _, y),
    node(y, layer, _),
    layer < max l : node(_, l, _).

edgeDeltaErrorVsOutInductive(edge, old_delta + cur_delta, index) :-
    edgeDeltaErrorVsOutInductive(edge, old_delta, old_index),
    index = old_index + 1,
    edge(edge, _, y),
    edge(next_edge, y, z),
    edgeWeight(_, next_edge, sub_delta3),
    node(z, _, index),
    edgeDeltaErrorVsOut(next_edge, sub_delta1),
    edgeDeltaOutVsNet(next_edge, sub_delta2),
    cur_delta = sub_delta1 * sub_delta2 * sub_delta3.

/**
 * Output
 */
.output newEdgeWeight
.output totalError
