#define EULER 2.71828
#define ETA 0.5

.type NodeID = number

/***
 * Configuration input
 */
.decl targetValue(id:NodeID, target:float)
.decl nodeBias(id:NodeID, value:float)
.decl node(id:NodeID, layer:number, index:number)
.decl edge(x:NodeID, y:NodeID, weight:float)

.input targetValue
.input nodeBias
.input node
.input edge

/***
 * Forward propagation
 */
.decl forward(id:NodeID, value:float)
// value of dummy input nodes is 1
forward(-1, 1).

forward(id, value + bias) :-
    node(id, layer, _),
    nodeBias(id, bias),
    forwardInductive(id, value, index),
    // stopping index is index of max prev layer node
    index = max x : { node(_, layer-1, x) }.

.decl activatedForward(id:NodeID, value:float)
activatedForward(id, value) :-
    forward(id, initial),
    node(id, layer, _),
    max_layer = max l : node(_, l, _),

    // sigmoid for output layer
    ((layer = max_layer, value = (1/(1+EULER^(-initial))));

    // sigmoid for hidden layers
     (layer < max_layer, layer > 0, value = (1/(1+EULER^(-initial))));

    // input nodes shouldnt change
     (layer <= 0, value = initial)).

// Inductive step to sum up all incoming values
// Induces an ordering based on previous layer indices
.decl forwardInductive(id:NodeID, rolling_value:float, index:number)
forwardInductive(id, 0.0, -1) :- node(id, _, _).
forwardInductive(id, prev_value + x1_value * weight, index) :-
    forwardInductive(id, prev_value, prev_index),
    index = prev_index + 1,
    node(x1_id, _, index),
    edge(x1_id, id, weight),
    activatedForward(x1_id, x1_value).

.decl nodeWeights(id:NodeID, layer:number, index:number, initial:float, activated:float)
nodeWeights(id, layer, index, initial, activated) :-
    forward(id, initial),
    activatedForward(id, activated),
    node(id, layer, index).

.decl totalError(error:float)
totalError(error) :-
    error = 0.5 * (sum (x * x) : {
        x = target - actual,
        targetValue(id, target),
        activatedForward(id, actual)}).

.decl newEdgeWeight(x:NodeID, y:NodeID, weight:float)
newEdgeWeight(x, y, old_weight - ETA * deltaErrorVsWeight) :-
    edge(x, y, old_weight),
    edgeDeltaErrorVsOut(x, y, deltaErrorVsOut),
    edgeDeltaOutVsNet(x, y, deltaOutVsNet),
    edgeDeltaNetVsWeight(x, y, deltaNetVsWeight),
    deltaErrorVsWeight = deltaErrorVsOut * deltaOutVsNet * deltaNetVsWeight.
.output newEdgeWeight()

/***
 * Back propagation
 */

.decl edgeDeltaOutVsNet(x:NodeID, y:NodeID, delta:float)
.output edgeDeltaOutVsNet()
edgeDeltaOutVsNet(x, y, delta) :-
    edge(x, y, _),
    activatedForward(y, out),
    delta = out * (1 - out).

.decl edgeDeltaNetVsWeight(x:NodeID, y:NodeID, delta:float)
.output edgeDeltaNetVsWeight()
edgeDeltaNetVsWeight(x, y, delta) :-
    edge(x, y, _),
    activatedForward(x, out),
    delta = out.

.decl edgeDeltaErrorVsOut(x:NodeID, y:NodeID, delta:float)
.output edgeDeltaErrorVsOut()
// For output layer
edgeDeltaErrorVsOut(x, y, delta) :-
    layer = max l : node(_, l, _),
    node(y, layer, _),
    targetValue(y, target),
    activatedForward(y, actual),
    edge(x, y, _),
    delta = actual - target.

// For hidden layers
edgeDeltaErrorVsOut(x, y, delta) :-
    edge(x, y, _),
    node(y, layer, _),
    edgeDeltaErrorVsOutInductive(x, y, delta, index),
    index = max x : { node(_, layer+1, x) }.

.decl edgeDeltaErrorVsOutInductive(x:NodeID, y:NodeID, rolling_delta:float, index:number)
edgeDeltaErrorVsOutInductive(x, y, 0, -1) :-
    edge(x, y, _),
    node(y, layer, _),
    layer < max l : node(_, l, _).

edgeDeltaErrorVsOutInductive(x, y, old_delta + cur_delta, index) :-
    edgeDeltaErrorVsOutInductive(x, y, old_delta, old_index),
    index = old_index + 1,
    edge(y, z, sub_delta3),
    node(z, _, index),
    edgeDeltaErrorVsOut(y, z, sub_delta1),
    edgeDeltaOutVsNet(y, z, sub_delta2),
    cur_delta = sub_delta1 * sub_delta2 * sub_delta3.

.output totalError()
.output nodeWeights()
