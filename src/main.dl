#define EULER 2.71828
#define ETA 0.5

.type NodeID = number

.decl targetValue(id:NodeID, target:float) input
.decl nodeBias(id:NodeID, value:float) input
.decl node(id:NodeID, layer:number, index:number) input
.decl edge(x:NodeID, y:NodeID, weight:float) input

.decl forward(id:NodeID, value:float)
// value of dummy input nodes is 1
forward(-1, 1).

forward(id, value + bias) :-
    node(id, layer, _),
    nodeBias(id, bias),
    forwardInductive(id, value, index),
    // stopping index is index of max prev layer node
    index = max x : { node(_, layer-1, x) }.

.decl activatedForward(id:NodeID, value:float)
activatedForward(id, value) :-
    forward(id, initial),
    node(id, layer, _),
    max_layer = max l : node(_, l, _),

    // sigmoid for output layer
    ((layer = max_layer, value = (1/(1+EULER^(-initial))));

    // sigmoid for hidden layers
     (layer < max_layer, layer > 0, value = (1/(1+EULER^(-initial))));

    // input nodes shouldnt change
     (layer <= 0, value = initial)).

// Inductive step to sum up all incoming values
// Induces an ordering based on previous layer indices
.decl forwardInductive(id:NodeID, rolling_value:float, index:number)
forwardInductive(id, 0.0, -1) :- node(id, _, _).
forwardInductive(id, prev_value + x1_value * weight, index) :-
    forwardInductive(id, prev_value, prev_index),
    index = prev_index + 1,
    node(x1_id, _, index),
    edge(x1_id, id, weight),
    activatedForward(x1_id, x1_value).

.decl nodeWeights(id:NodeID, layer:number, index:number, initial:float, activated:float)
nodeWeights(id, layer, index, initial, activated) :-
    forward(id, initial),
    activatedForward(id, activated),
    node(id, layer, index).

.decl totalError(error:float)
totalError(error) :-
    error = 0.5 * (sum (x * x) : {
        x = target - actual,
        targetValue(id, target),
        activatedForward(id, actual)}).

.decl newEdgeWeight(x:NodeID, y:NodeID, weight:float)
newEdgeWeight(x, y, old_weight - ETA * difference) :-
    edge(x, y, old_weight),
    edgeDiffTotalOut(x, y, diffTotalOut),
    edgeDiffOutNet(x, y, diffOutNet),
    edgeDiffNetWeight(x, y, diffNetWeight),
    difference = diffTotalOut * diffOutNet * diffNetWeight.
.output newEdgeWeight()

.decl edgeDiffTotalOut(x:NodeID, y:NodeID, weight:float)
edgeDiffTotalOut(x, y, actual - target) :-
    layer = max l : node(_, l, _),
    node(y, layer, _),
    targetValue(y, target),
    activatedForward(y, actual),
    edge(x, y, _).

.decl edgeDiffOutNet(x:NodeID, y:NodeID, weight:float)
edgeDiffOutNet(x, y, out * (1 - out)) :-
    activatedForward(y, out),
    edge(x, y, _).

.decl edgeDiffNetWeight(x:NodeID, y:NodeID, weight:float)
edgeDiffNetWeight(x, y, out) :-
    activatedForward(x, out),
    edge(x, y, _).

.output edgeDiffTotalOut()
.output edgeDiffOutNet()
.output edgeDiffNetWeight()

.output totalError()
.output nodeWeights()
