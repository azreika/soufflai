#define EULER 2.71828
#define ETA 0.5

.type NodeID = number

.decl targetValue(id:NodeID, target:float) input
.decl nodeBias(id:NodeID, value:float) input
.decl node(id:NodeID, layer:number, index:number) input
.decl edge(x:NodeID, y:NodeID, weight:float) input

.decl forward(id:NodeID, value:float)
// value of dummy input nodes is 1
forward(-1, 1).

forward(id, value + bias) :-
    node(id, layer, _),
    nodeBias(id, bias),
    forwardInductive(id, value, index),
    // stopping index is index of max prev layer node
    index = max x : { node(_, layer-1, x) }.

.decl activatedForward(id:NodeID, value:float)
activatedForward(id, value) :-
    forward(id, initial),
    node(id, layer, _),
    max_layer = max l : node(_, l, _),

    // sigmoid for output layer
    ((layer = max_layer, value = (1/(1+EULER^(-initial))));

    // sigmoid for hidden layers
     (layer < max_layer, layer > 0, value = (1/(1+EULER^(-initial))));

    // input nodes shouldnt change
     (layer <= 0, value = initial)).

// Inductive step to sum up all incoming values
// Induces an ordering based on previous layer indices
.decl forwardInductive(id:NodeID, rolling_value:float, index:number)
forwardInductive(id, 0.0, -1) :- node(id, _, _).
forwardInductive(id, prev_value + x1_value * weight, index) :-
    forwardInductive(id, prev_value, prev_index),
    index = prev_index + 1,
    node(x1_id, _, index),
    edge(x1_id, id, weight),
    activatedForward(x1_id, x1_value).

.decl nodeWeights(id:NodeID, layer:number, index:number, initial:float, activated:float)
nodeWeights(id, layer, index, initial, activated) :-
    forward(id, initial),
    activatedForward(id, activated),
    node(id, layer, index).

.decl totalError(error:float)
totalError(error) :-
    error = 0.5 * (sum (x * x) : {
        x = target - actual,
        targetValue(id, target),
        activatedForward(id, actual)}).

.decl newEdgeWeight(x:NodeID, y:NodeID, weight:float)
newEdgeWeight(x, y, old_weight - ETA * deltaErrorVsWeight) :-
    edge(x, y, old_weight),
    edgeDeltaErrorVsOut(x, y, deltaErrorVsOut),
    edgeDeltaOutVsNet(x, y, deltaOutVsNet),
    edgeDeltaNetVsWeight(x, y, deltaNetVsWeight),
    deltaErrorVsWeight = deltaErrorVsOut * deltaOutVsNet * deltaNetVsWeight.
.output newEdgeWeight()

.decl edgeDeltaOutVsNet(x:NodeID, y:NodeID, delta:float)
.output edgeDeltaOutVsNet()
edgeDeltaOutVsNet(x, y, delta) :-
    edge(x, y, _),
    activatedForward(y, out),
    delta = out * (1 - out).

.decl edgeDeltaNetVsWeight(x:NodeID, y:NodeID, delta:float)
.output edgeDeltaNetVsWeight()
edgeDeltaNetVsWeight(x, y, delta) :-
    edge(x, y, _),
    activatedForward(x, out),
    delta = out.

.decl edgeDeltaErrorVsOut(x:NodeID, y:NodeID, delta:float)
.output edgeDeltaErrorVsOut()
// For output layer
edgeDeltaErrorVsOut(x, y, delta) :-
    layer = max l : node(_, l, _),
    node(y, layer, _),
    targetValue(y, target),
    activatedForward(y, actual),
    edge(x, y, _),
    delta = actual - target.

// // For hidden layers
// edgeDiffTotalOut(x, y, result) :-
//     max_layer = max l : node(_, l, _),
//     node(y, layer, _),
//     layer < max_layer,
//     result = sum v : {
//         edge(y, end, _),
//         end_error_over_end_net = end_error_over_end_out * end_out_over_end_net,
//         edgeDiffOutNet(y, end, end_out_over_end_net),
//         activatedForward(end, actual),
//         targetValue(end, target),
//         end_error_over_end_out = actual - target,
//         v = end_error_over_end_net * end_net_over_y,
//         end_net_over_y`
//     }.

.output totalError()
.output nodeWeights()
